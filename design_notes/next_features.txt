- Make multi-window game display
- Load maps from JSON
- Link map navigation via stairs/doors/portals to new maps

Exploring maps with different features
- lighting in darkness important
- torches, lamps, spells
- hmm, explored/visible areas?

Make a series of maps that can be explored in a fun way.
Add stuff to collect.  Resources you can do stuff with.
What is the purpose of the game?
- Collect all 78 Tarot Cards.
- Complete the Fool's Journey ... what would that mean?

Do Tarot cards represent maps? Monsters? Ways of traversing?

Map Features to implement
-------------------------
- read maps definitions from JSON file
   - load phase
      - load build file into memory
   - build phase
      - run procedural generation algorithms for
         - map tile data
         - entities on map
   - link phase
      - link stairs, doors etc


Map System Generators
=====================
These generators create game content that encapsulates a portion
of the total game world.  For example, say you want logically
related and cohesive series of caves filled with valuable Crystals,
an ancient, abandoned Elven city, or a Goblin-infested dungeon.

Each of these "map systems" are generated by a given MapSystemGenerator,
which itself may be comprised of many smaller sub-component generators.

Other general examples include a dungeon, a tower, a cave system, or a city.

There will be different kinds of Map Systems, but each must have the
following kinds of properties:
 - Each map must have at least one path that eventually
   leads out of the given system into the World Map.

No soft-locking players in maps that contain no paths to further
game content.  However, the immediate path forward may be unclear.

For example, a trap door that causes you to fall X number of levels
into an unknown area of the dungeon, and you have to forge a new path
deeper, or out of, the dungeon.

Maybe they need to learn skills, find items, or forge an entirely
different path to get out.  As long as the Map System takes these
into account, then the design features are allowed.

Map System Generator features:
------------------------------

Growth Direction
 - which way do other maps connect to this one?
    - ex. DOWNWARD (dungeons), UPWARD (towers), OUTWARD (rooms, outdoors)


Actions/Turns Behavior
======================

All game entities have a set of behaviors they can take in which they interact
with the GameWorld.  These are called Actions.

Example Actions include moving, picking up items, opening a door, digging
through a wall, building something, etc.

What makes these Actions interesting?
- They modify the GameState.
- They consume some amount of Resources. (Nothing is free).

If it consumes no Resources, it is not an Action, but either:
- Only a UI event.
    - For example: a player inspecting the map with their mouse.
- It is a component of a larger, more encompassing Action.
    - For example: selecting the target of a spell a player will cast.

What kind of Resources exist in the game?

- GameTime:

  Each Action takes between 0 and some larger amount of ticks.
  Once an Entity commits to an action, that action cannot be completed
  until the cooldown of that Action has completed.  This is not tied to
  real-time, but only the game tick counter.

  Note that there are different phases of Action timing.  Is the action
  passive, so you can do other things while the cooldown is occurring?
  Or, is it active, meaning you are completely preoccupied for the turns
  it takes to complete the action?

  Or, does the action have an active and passive step?  For example,
  a large melee attack that strikes an enemy for double damage and takes
  10 active game ticks to execute, but then takes 100 passive game ticks
  to cooldown before you can use the skill again.

- Vital statistics:

  Each entity has a set of given vital statistics that are necessary for
  that entity to remain alive and thus take action in the game:

   - Health   Counter for physical damage against the Entity.        Empty causes death.
   - Stamina  Energy gained and consumed by taking certain Actions.  Empty causes passing out.
   - Hunger   Satiated confers a bonus; starving applies a penalty.  Empty causes death.

  Actions can effect these statistics. For example:
   - Melee attacks reduce the health of the entity targeted by the attack.
   - An Entity relieves its hunger by consuming Food.
   - Moving consumes stamina, based on the terrain type and Entity's stats.


Entities
========
An Entity is any game object that can inhabit a map.  GameMaps ONLY contain two
kinds of game objects, each on their own logical layers:

Terrain
-------
Terrain is the base layer for GameMaps.  For phase 1, Terrain info will be
entirely encapsulated within the given character assigned to each position in
the map grid.  So, all '.' will represent open ground with a given set of
assumed features.

Later iterations of the game may optionally store more information in the grid,
using a GameTerrain object instead of only char.  Then, tiles can have
variation in type, composition, and roughness, for example.  Type determines
the character used, and if the tile is passable.  Composition determines the
what base foreground and background colors the tile is rendered with, and also
what potential resources may be harvestable from this terrain feature.
Roughness determines what cost in resources moving through this tile incurs.

Should the movement cost be applied when moving /into/, or /out of/, a given
tile?  I prefer non-debit systems, so you can only commit to actions you can
afford to take.  So for general movement, you can only move onto a given tile
iff you can afford the cost in resources.

However, some stationary actions may also incur a movement cost.  For example,
consider the difference between Waiting and Resting.

Terrain, Actions, and An Aside About Dying
...........................................
Waiting you remain ready to respond with actions, but remain standing.  So, you
recover a minor amount of Stamina initially, but waiting too long (15+ turns)
begins to instead burn stamina, as the entity would prefer to walk around.  So,
a waiting action would incur no movement cost, as you remain in the same stance
as when you initially entered the tile.

Resting means you stop what you are doing and do as little as possible to
recover vital resources.  So at minimum, you disarm what you were carrying,
and find some means to either sit or lie down so that your body can rest.  In
this state, an Entity recovers more Stamina and some Health, but must actually
spend Stamina to begin or end the resting State, based on the terrain's
roughness.  Logically this makes sense.

For example, consider you decide to wade yourself through a thicket of thorny
brambles to cross through a section of a forest map.  Each step is incurring a
heavy Stamina cost, and also a chance of Health damage if you get scratched or
poked by the thorns.  It is possible in such a scenario to get stranded in the
middle of such a form of Terrain where movement will render you temporarily
immobile.  You get too exhausted, and begin to risk passing out.  So, you then
must choose to stop and rest to regain enough energy to continue with your
reckless choice of tramping through the brambles.  However, even finding a way
to rest is tricky, and requires more movement through the thorns to move from
a standing to resting position.  So if you mindlessly walk through bushes until
you physically cannot move anymore, you risk not being able to even choose a
Resting action, forcing you to Wait until either you can afford to Rest, or you
instead simply pass out, incurring all costs into the negative and hoping that
no life-critical stats reach zero and cause you to die.

Related to Waiting and Resting are Collapsing and Passing Out.  Both happen due
to extreme exhaustion.  Collapsing is like forced Resting, but the state is not
restful.  Passing Out is like Collapsing, except you have no awareness of
activity in the game until you Awaken again.

Causing an enemy to Collapse is sufficient if you desire to run away and not
be pursued.  Causing an enemy to Pass Out is sufficient to loot their body and
steal their belongings.  But experience from slaying an enemy in battle is not
gained unless the enemy actually Dies.  Although minor experience is gained
from many actions, such as using unmastered skills, such as striking an
opponent with your weapon.

Entities
--------
Entities are the objects and creatures that inhabit a given GameMap.  They live
above the Terrain in their own layers, occupying either a colliding or
non-colliding layer.  Non-colliding entities mean small objects or things you
can walk over, such as a necklace, piles of gold coins, a dropped backpack, or
a slain enemy.  Colliding entities incur special events when trying to interact,
or aka "bump" into them.


Validation
==========
What is my goal?

Validate game definitions loaded from JSON resource files meet some form of
standard criteria, before ever trying to use them.

Map Generators
==============
In an ideal world, my code base's map generators would have all these fancy,
beautifully designed classes that were a breeze to work with, and all easily
writable from a few simple and intuitive locations.

Unfortunately, due to the necessity of code reuse and how I have chosen to
redesign how I represent map data, I have a number of classes that now juggle
one another to accomplish the final generation mission.  And even these have
much room for improvement I can imagine for the future. The question is, how
much refactoring is worthwhile now to create a game that is fun and keeps my
inspiration's momentum moving forward?  Versus, what is simply a nice-to-have?

This is the current map generation architecture I've created:



                              ......JSON resource file
                              :             |
       GameMapDefinition .....:             |
               |                           \_/
     Maze      |                   JsonDefinitionLoader
        \      |                            |
         \     |                            |
         __|  \_/                          \_/
            GameMap  __             GameMapDefinition
               :    |                       |
               :       \                    |
               :         \                 \_/
               :           \_ _ _ _ GameMapGenerator
               :
               :
   [used in actual game logic]



GameMapDefinition
-----------------
JSON resource definition files (all in ONE class! oops).
Contains fields that map to different GameMap types.

GameMap
-------
The actual map type used in the game logic.  Has much room

JsonDefinitionLoader
--------------------
Responsible for loading GameMapDefinitions from the resources
folder into memory.  Has a validation and normalization step.
I'm thinking, too heavily architectured for this point in
game development.  I should remove the extra steps, and
K.I.S.S.

GameMapGenerator
----------------
Responsible for converting GameMapDefinitions into GameMaps.
This is a finely designed class, and easily has room to extend
or simply make extra generators, such as a VaultMapGenerator,
that can be delegated to and called by this main enclosing
class.

Maze
----
This is an older but highly robust map generation algorithm
class that I wrote for my MazeGame/Imbroglio projects while in
college.  This is a highly sentimental file, as it is both the
primary reason I fell in love with programming, and also my
gateway into discovering my fascination with roguelikes and
the more general topic of procedural generation algorithms.

When I successfully implemented my first maze generation
method and it carved out a two-dimensional maze of of paths
and walls, I was super ecstatic.  I wrote an antire game based
around exploring and showing off the output of that one chunk
of code.  I still haven't created a final version of that app
that fully satisfied me, and I will likely revisit and create
the final, polished version of Imbroglio: Classic eventually,
when the time is right and the project calls to me.

But regardless of the history of this class, it has many
incredibly helpful procedural generation algorithms defined
within, so I've been importing and using its code for now.

...

However, the current design is a bit overall clunky and has a
code smell of becoming monolithic with time.  For one, having
to convert between byte[][] of Mazes and char[][] of GameMaps
after generating a given grid is annoying.

I could take the desired algorithms out of Maze and create a
generics grid generator, which creates grids following
whatever given algorithms, but instead instantiates an actual
array of a specified ObjectType.  I'm not sure how beneficial
this is in terms of performance though, so having a simple
conversion algorithm written into the procedural generation
classes to convert grid types may be preferable.

What other algorithms can be implemented?  Consider graph
based approaches that model conceptual relations that must
be linked, and then these graphs drive the generation of
related 2D tile grids that a roguelike game can display for
the player to explore.

For example, a house's room layout may be understood by the
following graph design, representing my the first floor of
my parent's house:

                             ----------- Closet
                            |
                      MasterBedroom ---- Bathroom
                            |
                            |
                            |
                        DiningRoom ---------- Kitchen ---------- Breakfast Nook
                            |                                          |
                            |                                          |
                            |                            Pantry ----   |
                            |   ---- Bathroom                       |  |
                            |  |                                    Hallway
Entrance ---- Foyer ---- Hallway                                    |  |
                            |  |                     Downstairs ----   |    ---- Entrance
                            |   ---- Upstairs                          |   |
                            |                                      ArtStudio
                            |                                          |
                            ---------------- LivingRoom ---------------

This can then be used to generate any number of valid 2D grid
representations of this house made of paths and walls, with the
appropriate count of rooms laid out adjacent to one another with
doorways connecting them.

####=#####
#.O..+...#
=....#####
#....+..O# #####
###+########...#
#.............0=
=.....#.....#..#
#.....#.....####
##### #####.#
#...#+..#..####=##
+...+.#####.#....+
#...#.<# #>......#
#####.#######....#
#...........#....#
=................#
#...........#O...#
#=########=#####=#

Graphics Implementations
========================
Currently, I am using Zircon.  This is convenient as it has built-in,
simplified functionality for drawing characters in a tile grid to the
screen with specified foreground and background characters.

One annoyance is the fullscreen functionality doesn't work the way
that I prefer.

I could go back to adding full Swing functionality, but that would be
quite a bit of work to isolate the GOOD bits of my old JGameEngine's
graphics engine and make a simplified tile display.  I know I got a
simple character display working at some point, and I also know that
my implementation is far less CPU-intensive, as I can have microscopic
control over when each sprite is updated and the screen is re-rendered.

This would be highly preferrable to having my Mac running hot if Zircon
is running for longer than say 30 seconds on my machine.

Unfortunately, the amount of work to design this tile grid interface
would be ... a few days of work.  Maybe I could bash it out in a few
hours, if I designed my graphics interface and wrote adapters for both
Zircon and my game engine's Swing implementation.

That would be an interesting project.  I may do that after I get
stairs and doors functionality working on the map navigation.

Stairs:
-------
The next thing I desire to implement is, the stairs! First for vaults.
Then, how might I configure stairs and portals for other maps?  Also,
pull the spriteKey definitions out of GameMapDefinition, and into a
more general tile definitions file.  Create four sprite sets, one for
each element of the Quaternity.

Tarot Cards:
------------
Actually, let's begin implementing the meat of the game: the appearance
of the Tarot Cards.  I want to design the tiny cards, where you can
create spreads and interact with the decks.

